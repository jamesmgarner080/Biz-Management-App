{'role': 'assistant', 'content': '<function_calls>\n<create-file file_path="backend/database.js">\nconst Database = require(\'better-sqlite3\');\nconst fs = require(\'fs\');\nconst path = require(\'path\');\nconst bcrypt = require(\'bcrypt\');\n\nclass DatabaseManager {\n    constructor() {\n        const dbPath = process.env.DATABASE_PATH || \'./database/business_management.db\';\n        const dbDir = path.dirname(dbPath);\n        \n        // Create database directory if it doesn\'t exist\n        if (!fs.existsSync(dbDir)) {\n            fs.mkdirSync(dbDir, { recursive: true });\n        }\n        \n        this.db = new Database(dbPath);\n        this.db.pragma(\'journal_mode = WAL\');\n        this.db.pragma(\'foreign_keys = ON\');\n        \n        this.initializeDatabase();\n    }\n    \n    initializeDatabase() {\n        const schemaPath = path.join(__dirname, \'../database/schema.sql\');\n        \n        if (fs.existsSync(schemaPath)) {\n            const schema = fs.readFileSync(schemaPath, \'utf8\');\n            \n            // Split by semicolon and execute each statement\n            const statements = schema.split(\';\').filter(stmt => stmt.trim());\n            \n            statements.forEach(statement => {\n                try {\n                    this.db.exec(statement);\n                } catch (error) {\n                    console.error(\'Error executing statement:\', error.message);\n                }\n            });\n            \n            console.log(\'Database initialized successfully\');\n            this.createDefaultAdmin();\n        } else {\n            console.error(\'Schema file not found\');\n        }\n    }\n    \n    async createDefaultAdmin() {\n        try {\n            const existingAdmin = this.db.prepare(\'SELECT id FROM users WHERE username = ?\').get(\'admin\');\n            \n            if (!existingAdmin) {\n                const password = process.env.DEFAULT_ADMIN_PASSWORD || \'admin123\';\n                const passwordHash = await bcrypt.hash(password, 10);\n                \n                this.db.prepare(`\n                    INSERT INTO users (username, password_hash, role, full_name, email)\n                    VALUES (?, ?, ?, ?, ?)\n                `).run(\'admin\', passwordHash, \'management\', \'System Administrator\', \'admin@example.com\');\n                \n                console.log(\'Default admin user created\');\n                console.log(\'Username: admin\');\n                console.log(\'Password: admin123\');\n                console.log(\'PLEASE CHANGE THE PASSWORD IMMEDIATELY!\');\n            }\n        } catch (error) {\n            console.error(\'Error creating default admin:\', error.message);\n        }\n    }\n    \n    // User operations\n    getUserByUsername(username) {\n        return this.db.prepare(\'SELECT * FROM users WHERE username = ?\').get(username);\n    }\n    \n    getUserById(id) {\n        return this.db.prepare(\'SELECT id, username, role, full_name, email, phone, active FROM users WHERE id = ?\').get(id);\n    }\n    \n    getAllUsers() {\n        return this.db.prepare(\'SELECT id, username, role, full_name, email, phone, active, created_at FROM users ORDER BY full_name\').all();\n    }\n    \n    getActiveUsers() {\n        return this.db.prepare(\'SELECT id, username, role, full_name, email FROM users WHERE active = 1 ORDER BY full_name\').all();\n    }\n    \n    createUser(userData) {\n        const stmt = this.db.prepare(`\n            INSERT INTO users (username, password_hash, role, full_name, email, phone)\n            VALUES (?, ?, ?, ?, ?, ?)\n        `);\n        return stmt.run(\n            userData.username,\n            userData.password_hash,\n            userData.role,\n            userData.full_name,\n            userData.email,\n            userData.phone\n        );\n    }\n    \n    updateUser(id, userData) {\n        const stmt = this.db.prepare(`\n            UPDATE users \n            SET full_name = ?, email = ?, phone = ?, role = ?\n            WHERE id = ?\n        `);\n        return stmt.run(userData.full_name, userData.email, userData.phone, userData.role, id);\n    }\n    \n    updateUserPassword(id, passwordHash) {\n        return this.db.prepare(\'UPDATE users SET password_hash = ? WHERE id = ?\').run(passwordHash, id);\n    }\n    \n    updateLastLogin(id) {\n        return this.db.prepare(\'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = ?\').run(id);\n    }\n    \n    // Task operations\n    createTask(taskData) {\n        const stmt = this.db.prepare(`\n            INSERT INTO tasks (\n                title, description, category, priority, assignment_type,\n                assigned_to, assigned_date, due_date, due_time, recurrence, created_by\n            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `);\n        return stmt.run(\n            taskData.title,\n            taskData.description,\n            taskData.category,\n            taskData.priority,\n            taskData.assignment_type,\n            taskData.assigned_to || null,\n            taskData.assigned_date || null,\n            taskData.due_date,\n            taskData.due_time,\n            taskData.recurrence || \'none\',\n            taskData.created_by\n        );\n    }\n    \n    getTaskById(id) {\n        return this.db.prepare(`\n            SELECT t.*, \n                   u1.full_name as assigned_to_name,\n                   u2.full_name as created_by_name,\n                   u3.full_name as completed_by_name\n            FROM tasks t\n            LEFT JOIN users u1 ON t.assigned_to = u1.id\n            LEFT JOIN users u2 ON t.created_by = u2.id\n            LEFT JOIN users u3 ON t.completed_by = u3.id\n            WHERE t.id = ?\n        `).get(id);\n    }\n    \n    getAllTasks() {\n        return this.db.prepare(`\n            SELECT t.*, \n                   u1.full_name as assigned_to_name,\n                   u2.full_name as created_by_name\n            FROM tasks t\n            LEFT JOIN users u1 ON t.assigned_to = u1.id\n            LEFT JOIN users u2 ON t.created_by = u2.id\n            ORDER BY t.due_date DESC, t.priority DESC\n        `).all();\n    }\n    \n    getTasksByUser(userId) {\n        return this.db.prepare(`\n            SELECT t.*, \n                   u1.full_name as created_by_name\n            FROM tasks t\n            LEFT JOIN users u1 ON t.created_by = u1.id\n            WHERE t.assigned_to = ? OR (\n                t.assignment_type = \'shift-based\' AND \n                t.assigned_date IN (\n                    SELECT shift_date FROM shift_schedules WHERE user_id = ?\n                )\n            )\n            ORDER BY t.due_date DESC, t.priority DESC\n        `).all(userId, userId);\n    }\n    \n    getTasksByDate(date) {\n        return this.db.prepare(`\n            SELECT t.*, \n                   u1.full_name as assigned_to_name,\n                   u2.full_name as created_by_name\n            FROM tasks t\n            LEFT JOIN users u1 ON t.assigned_to = u1.id\n            LEFT JOIN users u2 ON t.created_by = u2.id\n            WHERE DATE(t.assigned_date) = DATE(?) OR DATE(t.due_date) = DATE(?)\n            ORDER BY t.priority DESC\n        `).all(date, date);\n    }\n    \n    getShiftTasksForDate(date) {\n        return this.db.prepare(`\n            SELECT t.*, u.full_name as created_by_name\n            FROM tasks t\n            LEFT JOIN users u ON t.created_by = u.id\n            WHERE t.assignment_type = \'shift-based\' \n            AND DATE(t.assigned_date) = DATE(?)\n            AND t.status != \'completed\'\n            ORDER BY t.priority DESC\n        `).all(date);\n    }\n    \n    updateTask(id, taskData) {\n        const stmt = this.db.prepare(`\n            UPDATE tasks \n            SET title = ?, description = ?, category = ?, priority = ?,\n                assignment_type = ?, assigned_to = ?, assigned_date = ?,\n                due_date = ?, due_time = ?, recurrence = ?\n            WHERE id = ?\n        `);\n        return stmt.run(\n            taskData.title,\n            taskData.description,\n            taskData.category,\n            taskData.priority,\n            taskData.assignment_type,\n            taskData.assigned_to || null,\n            taskData.assigned_date || null,\n            taskData.due_date,\n            taskData.due_time,\n            taskData.recurrence || \'none\',\n            id\n        );\n    }\n    \n    completeTask(id, userId, notes, photoPath) {\n        const stmt = this.db.prepare(`\n            UPDATE tasks \n            SET status = \'completed\',\n                completed_at = CURRENT_TIMESTAMP,\n                completed_by = ?,\n                completion_notes = ?,\n                completion_photo = ?\n            WHERE id = ?\n        `);\n        return stmt.run(userId, notes, photoPath, id);\n    }\n    \n    updateTaskStatus(id, status) {\n        return this.db.prepare(\'UPDATE tasks SET status = ? WHERE id = ?\').run(status, id);\n    }\n    \n    deleteTask(id) {\n        return this.db.prepare(\'DELETE FROM tasks WHERE id = ?\').run(id);\n    }\n    \n    // Notification operations\n    createNotification(userId, taskId, message, type) {\n        const stmt = this.db.prepare(`\n            INSERT INTO notifications (user_id, task_id, message, type)\n            VALUES (?, ?, ?, ?)\n        `);\n        return stmt.run(userId, taskId, message, type);\n    }\n    \n    getUserNotifications(userId, unreadOnly = false) {\n        let query = `\n            SELECT n.*, t.title as task_title\n            FROM notifications n\n            LEFT JOIN tasks t ON n.task_id = t.id\n            WHERE n.user_id = ?\n        `;\n        \n        if (unreadOnly) {\n            query += \' AND n.read = 0\';\n        }\n        \n        query += \' ORDER BY n.created_at DESC LIMIT 50\';\n        \n        return this.db.prepare(query).all(userId);\n    }\n    \n    markNotificationRead(id) {\n        return this.db.prepare(\'UPDATE notifications SET read = 1 WHERE id = ?\').run(id);\n    }\n    \n    markAllNotificationsRead(userId) {\n        return this.db.prepare(\'UPDATE notifications SET read = 1 WHERE user_id = ?\').run(userId);\n    }\n    \n    // Shift schedule operations\n    createShiftSchedule(scheduleData) {\n        const stmt = this.db.prepare(`\n            INSERT INTO shift_schedules (user_id, shift_date, shift_start, shift_end, role, notes)\n            VALUES (?, ?, ?, ?, ?, ?)\n        `);\n        return stmt.run(\n            scheduleData.user_id,\n            scheduleData.shift_date,\n            scheduleData.shift_start,\n            scheduleData.shift_end,\n            scheduleData.role,\n            scheduleData.notes\n        );\n    }\n    \n    getShiftSchedulesByDate(date) {\n        return this.db.prepare(`\n            SELECT s.*, u.full_name, u.username\n            FROM shift_schedules s\n            JOIN users u ON s.user_id = u.id\n            WHERE DATE(s.shift_date) = DATE(?)\n            ORDER BY s.shift_start\n        `).all(date);\n    }\n    \n    getShiftSchedulesByUser(userId, startDate, endDate) {\n        return this.db.prepare(`\n            SELECT * FROM shift_schedules\n            WHERE user_id = ? \n            AND shift_date BETWEEN ? AND ?\n            ORDER BY shift_date, shift_start\n        `).all(userId, startDate, endDate);\n    }\n    \n    getUsersOnShift(date) {\n        return this.db.prepare(`\n            SELECT DISTINCT u.id, u.username, u.full_name, u.role\n            FROM shift_schedules s\n            JOIN users u ON s.user_id = u.id\n            WHERE DATE(s.shift_date) = DATE(?)\n        `).all(date);\n    }\n    \n    // Task template operations\n    createTaskTemplate(templateData) {\n        const stmt = this.db.prepare(`\n            INSERT INTO task_templates (name, description, category, priority, estimated_duration, recurrence_pattern, created_by)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n        `);\n        return stmt.run(\n            templateData.name,\n            templateData.description,\n            templateData.category,\n            templateData.priority,\n            templateData.estimated_duration,\n            templateData.recurrence_pattern,\n            templateData.created_by\n        );\n    }\n    \n    getAllTaskTemplates() {\n        return this.db.prepare(\'SELECT * FROM task_templates ORDER BY name\').all();\n    }\n    \n    getTaskTemplateById(id) {\n        return this.db.prepare(\'SELECT * FROM task_templates WHERE id = ?\').get(id);\n    }\n    \n    deleteTaskTemplate(id) {\n        return this.db.prepare(\'DELETE FROM task_templates WHERE id = ?\').run(id);\n    }\n    \n    // Audit log\n    logAction(userId, action, entityType, entityId, details, ipAddress) {\n        const stmt = this.db.prepare(`\n            INSERT INTO audit_log (user_id, action, entity_type, entity_id, details, ip_address)\n            VALUES (?, ?, ?, ?, ?, ?)\n        `);\n        return stmt.run(userId, action, entityType, entityId, details, ipAddress);\n    }\n    \n    // Statistics and reports\n    getTaskStatistics() {\n        return {\n            total: this.db.prepare(\'SELECT COUNT(*) as count FROM tasks\').get().count,\n            completed: this.db.prepare(\'SELECT COUNT(*) as count FROM tasks WHERE status = "completed"\').get().count,\n            pending: this.db.prepare(\'SELECT COUNT(*) as count FROM tasks WHERE status = "pending"\').get().count,\n            overdue: this.db.prepare(\'SELECT COUNT(*) as count FROM tasks WHERE status = "overdue"\').get().count,\n            byCategory: this.db.prepare(\'SELECT category, COUNT(*) as count FROM tasks GROUP BY category\').all(),\n            byPriority: this.db.prepare(\'SELECT priority, COUNT(*) as count FROM tasks GROUP BY priority\').all()\n        };\n    }\n    \n    close() {\n        this.db.close();\n    }\n}\n\nmodule.exports = DatabaseManager;\n</create-file>\n</function_calls>'}