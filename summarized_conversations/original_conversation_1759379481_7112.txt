{'role': 'assistant', 'content': 'Now let\'s add the summary report generation method to the PDF generator:\n\n<function_calls>\n<str-replace file_path="backend/utils/pdf-generator.js">\n<old_str>    generateUserReport(user, tasks, schedules, outputPath) {\n        return new Promise((resolve, reject) => {\n            try {\n                const doc = new PDFDocument({ margin: 50 });\n                const stream = fs.createWriteStream(outputPath);\n                \n                doc.pipe(stream);\n                \n                // Header\n                doc.fontSize(20).text(\'User Performance Report\', { align: \'center\' });\n                doc.moveDown();\n                \n                // User info\n                doc.fontSize(14).text(\'User Information\', { underline: true });\n                doc.fontSize(10);\n                doc.text(`Name: ${user.full_name}`);\n                doc.text(`Username: ${user.username}`);\n                doc.text(`Role: ${user.role}`);\n                doc.text(`Email: ${user.email || \'N/A\'}`);\n                doc.moveDown();\n                \n                // Task statistics\n                doc.fontSize(14).text(\'Task Statistics\', { underline: true });\n                doc.fontSize(10);\n                \n                const completedTasks = tasks.filter(t => t.status === \'completed\').length;\n                const pendingTasks = tasks.filter(t => t.status === \'pending\').length;\n                const overdueTasks = tasks.filter(t => t.status === \'overdue\').length;\n                \n                doc.text(`Total Tasks: ${tasks.length}`);\n                doc.text(`Completed: ${completedTasks}`);\n                doc.text(`Pending: ${pendingTasks}`);\n                doc.text(`Overdue: ${overdueTasks}`);\n                doc.text(`Completion Rate: ${tasks.length > 0 ? ((completedTasks / tasks.length) * 100).toFixed(1) : 0}%`);\n                doc.moveDown();\n                \n                // Recent tasks\n                doc.fontSize(14).text(\'Recent Tasks\', { underline: true });\n                doc.moveDown();\n                \n                tasks.slice(0, 10).forEach((task, index) => {\n                    if (doc.y > 700) {\n                        doc.addPage();\n                    }\n                    \n                    doc.fontSize(11).text(`${index + 1}. ${task.title}`);\n                    doc.fontSize(9);\n                    doc.text(`Status: ${task.status} | Priority: ${task.priority} | Category: ${task.category}`);\n                    if (task.status === \'completed\' && task.completed_at) {\n                        doc.text(`Completed: ${task.completed_at}`);\n                    }\n                    doc.moveDown(0.5);\n                });\n                \n                doc.end();\n                \n                stream.on(\'finish\', () => {\n                    resolve(outputPath);\n                });\n                \n                stream.on(\'error\', (error) => {\n                    reject(error);\n                });\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n}</old_str>\n<new_str>    generateUserReport(user, tasks, schedules, outputPath) {\n        return new Promise((resolve, reject) => {\n            try {\n                const doc = new PDFDocument({ margin: 50 });\n                const stream = fs.createWriteStream(outputPath);\n                \n                doc.pipe(stream);\n                \n                // Header\n                doc.fontSize(20).text(\'User Performance Report\', { align: \'center\' });\n                doc.moveDown();\n                \n                // User info\n                doc.fontSize(14).text(\'User Information\', { underline: true });\n                doc.fontSize(10);\n                doc.text(`Name: ${user.full_name}`);\n                doc.text(`Username: ${user.username}`);\n                doc.text(`Role: ${user.role}`);\n                doc.text(`Email: ${user.email || \'N/A\'}`);\n                doc.moveDown();\n                \n                // Task statistics\n                doc.fontSize(14).text(\'Task Statistics\', { underline: true });\n                doc.fontSize(10);\n                \n                const completedTasks = tasks.filter(t => t.status === \'completed\').length;\n                const pendingTasks = tasks.filter(t => t.status === \'pending\').length;\n                const overdueTasks = tasks.filter(t => t.status === \'overdue\').length;\n                \n                doc.text(`Total Tasks: ${tasks.length}`);\n                doc.text(`Completed: ${completedTasks}`);\n                doc.text(`Pending: ${pendingTasks}`);\n                doc.text(`Overdue: ${overdueTasks}`);\n                doc.text(`Completion Rate: ${tasks.length > 0 ? ((completedTasks / tasks.length) * 100).toFixed(1) : 0}%`);\n                doc.moveDown();\n                \n                // Recent tasks\n                doc.fontSize(14).text(\'Recent Tasks\', { underline: true });\n                doc.moveDown();\n                \n                tasks.slice(0, 10).forEach((task, index) => {\n                    if (doc.y > 700) {\n                        doc.addPage();\n                    }\n                    \n                    doc.fontSize(11).text(`${index + 1}. ${task.title}`);\n                    doc.fontSize(9);\n                    doc.text(`Status: ${task.status} | Priority: ${task.priority} | Category: ${task.category}`);\n                    if (task.status === \'completed\' && task.completed_at) {\n                        doc.text(`Completed: ${task.completed_at}`);\n                    }\n                    doc.moveDown(0.5);\n                });\n                \n                doc.end();\n                \n                stream.on(\'finish\', () => {\n                    resolve(outputPath);\n                });\n                \n                stream.on(\'error\', (error) => {\n                    reject(error);\n                });\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    \n    generateSummaryReport(tasks, users, options, outputPath) {\n        return new Promise((resolve, reject) => {\n            try {\n                const doc = new PDFDocument({ margin: 50 });\n                const stream = fs.createWriteStream(outputPath);\n                \n                doc.pipe(stream);\n                \n                // Header\n                doc.fontSize(20).text(\'Business Summary Report\', { align: \'center\' });\n                doc.moveDown();\n                \n                // Report metadata\n                doc.fontSize(10);\n                doc.text(`Generated: ${new Date().toLocaleString()}`, { align: \'right\' });\n                if (options.dateFrom || options.dateTo) {\n                    doc.text(`Period: ${options.dateFrom || \'Start\'} to ${options.dateTo || \'End\'}`, { align: \'right\' });\n                }\n                doc.moveDown();\n                \n                // Overall Statistics\n                doc.fontSize(16).text(\'Overall Statistics\', { underline: true });\n                doc.fontSize(10);\n                doc.moveDown(0.5);\n                \n                const totalTasks = tasks.length;\n                const completedTasks = tasks.filter(t => t.status === \'completed\').length;\n                const pendingTasks = tasks.filter(t => t.status === \'pending\').length;\n                const overdueTasks = tasks.filter(t => t.status === \'overdue\').length;\n                const inProgressTasks = tasks.filter(t => t.status === \'in-progress\').length;\n                \n                doc.text(`Total Tasks: ${totalTasks}`);\n                doc.text(`Completed: ${completedTasks} (${totalTasks > 0 ? ((completedTasks / totalTasks) * 100).toFixed(1) : 0}%)`);\n                doc.text(`Pending: ${pendingTasks}`);\n                doc.text(`In Progress: ${inProgressTasks}`);\n                doc.text(`Overdue: ${overdueTasks}`);\n                doc.text(`Active Users: ${users.filter(u => u.active).length}`);\n                doc.moveDown();\n                \n                // Category Breakdown\n                if (options.includeCategoryBreakdown) {\n                    doc.fontSize(16).text(\'Tasks by Category\', { underline: true });\n                    doc.fontSize(10);\n                    doc.moveDown(0.5);\n                    \n                    const categories = {};\n                    tasks.forEach(task => {\n                        if (!categories[task.category]) {\n                            categories[task.category] = { total: 0, completed: 0 };\n                        }\n                        categories[task.category].total++;\n                        if (task.status === \'completed\') {\n                            categories[task.category].completed++;\n                        }\n                    });\n                    \n                    Object.keys(categories).sort().forEach(category => {\n                        const stats = categories[category];\n                        const completionRate = stats.total > 0 ? ((stats.completed / stats.total) * 100).toFixed(1) : 0;\n                        doc.text(`${category}: ${stats.total} tasks (${stats.completed} completed, ${completionRate}% completion rate)`);\n                    });\n                    doc.moveDown();\n                }\n                \n                // Priority Breakdown\n                doc.fontSize(16).text(\'Tasks by Priority\', { underline: true });\n                doc.fontSize(10);\n                doc.moveDown(0.5);\n                \n                const priorities = { High: 0, Medium: 0, Low: 0 };\n                tasks.forEach(task => {\n                    if (priorities[task.priority] !== undefined) {\n                        priorities[task.priority]++;\n                    }\n                });\n                \n                Object.keys(priorities).forEach(priority => {\n                    doc.text(`${priority}: ${priorities[priority]} tasks`);\n                });\n                doc.moveDown();\n                \n                // User Statistics\n                if (options.includeUserStats) {\n                    doc.addPage();\n                    doc.fontSize(16).text(\'User Performance\', { underline: true });\n                    doc.fontSize(10);\n                    doc.moveDown(0.5);\n                    \n                    users.forEach(user => {\n                        if (doc.y > 700) {\n                            doc.addPage();\n                        }\n                        \n                        const userTasks = tasks.filter(t => t.assigned_to === user.id);\n                        const userCompleted = userTasks.filter(t => t.status === \'completed\').length;\n                        const completionRate = userTasks.length > 0 ? ((userCompleted / userTasks.length) * 100).toFixed(1) : 0;\n                        \n                        doc.fontSize(12).text(`${user.full_name} (${user.role})`, { bold: true });\n                        doc.fontSize(10);\n                        doc.text(`  Total Tasks: ${userTasks.length}`);\n                        doc.text(`  Completed: ${userCompleted}`);\n                        doc.text(`  Completion Rate: ${completionRate}%`);\n                        doc.moveDown(0.5);\n                    });\n                }\n                \n                // Footer\n                const pages = doc.bufferedPageRange();\n                for (let i = 0; i < pages.count; i++) {\n                    doc.switchToPage(i);\n                    doc.fontSize(8).text(\n                        `Page ${i + 1} of ${pages.count}`,\n                        50,\n                        doc.page.height - 50,\n                        { align: \'center\' }\n                    );\n                }\n                \n                doc.end();\n                \n                stream.on(\'finish\', () => {\n                    resolve(outputPath);\n                });\n                \n                stream.on(\'error\', (error) => {\n                    reject(error);\n                });\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n}</new_str>\n</str-replace>\n</function_calls>'}